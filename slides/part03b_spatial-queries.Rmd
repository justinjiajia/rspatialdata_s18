---
title: "<span class='pres-date'>Week `r params$this_week`: </span><br/><span class='pres-subtitle'>Spatial Data Analysis with R</span> <br/><span class='pres-date'>`r load('../common/course_info.RData'); lstCI[[paste0('class0', params$this_week)]]`</span>"
author: "<span class='pres-title'>Spatial Queries</span>"
output: 
  slidy_presentation:
    css: "../common/slidy_styles.css"
    df_print: default
    duration: 0
    font_adjustment: 2
    footer:  !expr load('../common/course_info.RData'); paste("<span class='footer-right'><a href='acknowledgements.html'>Acknowledgements</a></span><span class='footer-right'><a href='../index.html'>Course Homepage</a></span><span class='footer-right'>Etherpad:&nbsp<a href='", lstCI$etherpadshort, "' target='_blank'>", lstCI$etherpadshort, "</a></span><span class='footer-subtitle'>Spatial Data Analysis in R</span>")
    self_contained: no
    lib_dir: lib
    smart: no
    includes:
      in_header: "../common/header.html"
params:
    this_week: 3
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(kableExtra)
library(rgdal)
library(rgeos)
```

# Spatial Queries

<div class="indented1">
Spatial Queries: Selecting features based on their location.

Absolute location - based on their coordinate values

Relative location - based on proximity to other features, including:

<div class="indented2">
- falls within  
- touches  
- contains  
- within distance  
- intersects  
- closest  
</div>
</div>

## Related concepts

<div class="indented1">
Attribute query - select features based on their attribute values

Spatial join - Spatial query followed by copying the attributes of selected features (also called Spatial Enrichment)
</div>

## Packages with Spatial Query Functions


```{r, echo=FALSE, results='asis'}
knitr::knit_hooks$set(small.mar = function(before, options, envir) {
    if (before) par(mar = c(2, 2, 0.5, 0.5))
})
library(kableExtra)
tbl_vec <- c("sp", "over()", "rgeos", "gIntersects", "FNN", "get.knn()", "raster", "extract()", "rgeos", "gContains(), gCovers(), gEquals(), gIntersects(), gOverlaps(), gTouches(), gWithinDistance()")
tbl_mat <- matrix(tbl_vec, byrow=TRUE, ncol=2, dimnames=list(1:(length(tbl_vec)/2), c("Package", "Function(s)")))
knitr::kable(tbl_mat, format = "html", table.attr='class="tbl_compact"') %>% column_spec(column=2, monospace = TRUE)
```

# <tt>sp::over(x,y)</tt>

<div class="indented1">
- does many types of spatial overlays and joins  
- <tt>x</tt> and <tt>y</tt> must have identical CRS
- what you get back depends on the class of <tt>x</tt> and <tt>y</tt> (about a dozen possibilities)
</div>

<div class="indented2">

<div class="indented2" style="font-family:monospace;">x = "SpatialPoints", y = "SpatialPolygons"</div>

<div class="indented3" style="font:size:90%; font-style:italic; color:darkblue;">
returns a numeric vector of length equal to the number of points; the number is the index (number) of the polygon of y in which a point falls; NA denotes the point does not fall in a polygon; if a point falls in multiple polygons, the last polygon is recorded.
</div>

<div class="indented2" style="font-family:monospace;">x = "SpatialPointsDataFrame", y = "SpatialPolygons"</div>
<div class="indented3" style="font:size:90%; font-style:italic; color:darkblue;">
equal to the previous method, except that an argument fn=xxx is allowed, e.g. fn = mean which will then report a data.frame with the mean attribute values of the x points falling in each polygon (set) of y
</div>

<div class="indented2" style="font-family:monospace;">x = "SpatialPoints", y = "SpatialPolygonsDataFrame"</div>
<div class="indented3" style="font:size:90%; font-style:italic; color:darkblue;">
returns a data.frame of the second argument with row entries corresponding to the first argument
</div>

<div class="indented2" style="font-family:monospace;">x = "SpatialPolygons", y = "SpatialPoints"</div>

<div class="indented3" style="font:size:90%; font-style:italic; color:darkblue;">
returns the polygon index of points in y; if x is a SpatialPolygonsDataFrame, a data.frame with rows from x corresponding to points in y is returned.
</div>

*and several others...*
</div>

__Using <tt>sp::over(x,y)</tt> effectively __

<div class="indented1">
You have to read the details closely (if this makes your head hurt, you're not alone!).

Remember that a <tt>SpatialPoints</tt> and <tt>SpatialPointsDataFrame</tt> are two different object types. 

<p style="margin-left: 3em;">But you can drop the data frame of any _Spatial*_ object with the <tt>geometry()</tt> function</p>

</div>

__Example__: Compute the number of cannabis dispenaries in San Francisco per neighborhood

1. Import the SF neighborhood boundaries and the cannabis dispensary locations. 

```{r load_data, fig.align="center", small.mar=TRUE, cache=TRUE}
library(rgdal)
sfnb_ll <- rgdal::readOGR("../exercises/data", "sf_neighborhoods", verbose=FALSE)
fn <- "../exercises/data/sf_permitted_cannabis_dispensaries_2014.kml"
sfpot_ll <- rgdal::readOGR(fn, "Cannabis Dispensaries 2014", verbose=FALSE)
sfpot_ll <- sp::spTransform(sfpot_ll, sfnb_ll@proj4string)
plot(sfnb_ll, axes=T, asp=1)
plot(sfpot_ll, add=T, col="red", pch=16)
```

2. Compute the number of dispensaries per neighborhood

```{r}
sfpot_nb_idx <- sp::over(geometry(sfpot_ll), geometry(sfnb_ll))
sfpot_nb_str <- sfnb_ll@data$nhood[sfpot_nb_idx]
sfpot_nb_str <- as.character(sfpot_nb_str)  ## change factor to a character
table(sfpot_nb_str)
```

# Spatial Queries with square brackets

To do a Spatial Query based on contains or overlays relationship, can you use the traditional [square bracket] notation. 

Syntax: <tt>my_spatial_points[*rows*, ]</tt>  

For the *rows* expression provide a Spatial* object containing the feature(s) you want to use for selection.  

__Example__: select the dispensaries that fall in the Mission neighborhood.

```{r msn_bnd, fig.align="center", small.mar=TRUE, cache=TRUE}
msn_bnd <- sfnb_ll[sfnb_ll$nhood=="Mission",]
msnpot_pnts <- sfpot_ll[msn_bnd, ]
nrow(msnpot_pnts)
plot(msn_bnd, axes=TRUE)
plot(msnpot_pnts, add=TRUE)
```

# *rgeos* Spatial Query Functions

The rgeos package contains a number of spatial query functions, including: 

<div class="indented2" style="font-family:monospace;">
gContains()  
gCovers()  
gEquals()  
gIntersects()  
gOverlaps()  
gTouches()  
gWithinDistance()  
</div>

Many of these use the <tt>byid</tt> argument to control whether the test is performed for individual features or the spatial layer as a whole.  

Like the <tt>over()</tt> function, you have to read the help page carefully.

__Example__: Find the cannabis dispensary in the Mission neighborhood using the *gContains()* function.

```{r rgeos_plot, fig.align="center", small.mar=TRUE, cache=TRUE}
library(rgeos)
x_matrix <- rgeos::gContains(msn_bnd, sfpot_ll, byid=c(F,T))

## gContains returns a matrix, in this case just one column
## Let's pull out that one column as a vector.
x_vec <- x_matrix[,1]   
table(x_vec)
plot(msn_bnd, axes=TRUE)
plot(sfpot_ll[x_vec,], add=TRUE, col="green")
```

## Extracting pixel values from raster data

Another type of spatial query is selecting and extracting pixel values that overlap features of interest.

We will see how to do this when we get to the *raster* package.

# Next Up

[Exercise 9: Spatial Queries](../exercises/ex09_spatial-queries.html){target="_blank"}

[Raster Data Pt. 1 - Importing and Basic Processing](part03c_raster-pt1.html)


